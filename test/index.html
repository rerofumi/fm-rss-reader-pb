<!doctype html>
<html lang="ja">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>fm-rss-reader-pb | Auth & API Tester</title>
  <style>
    body { font-family: system-ui, -apple-system, Segoe UI, Roboto, sans-serif; margin: 0; padding: 0; background: #0b1020; color: #e6e6e6; }
    header { padding: 16px; background: #141a33; display: flex; align-items: center; justify-content: space-between; }
    header h1 { margin: 0; font-size: 16px; font-weight: 600; }
    main { padding: 16px; display: grid; gap: 16px; grid-template-columns: repeat(auto-fit, minmax(320px, 1fr)); }
    section { background: #11162b; border: 1px solid #1f274a; border-radius: 8px; padding: 16px; }
    h2 { margin: 0 0 12px; font-size: 14px; color: #9fb4ff; }
    label { display: block; font-size: 12px; margin: 8px 0 4px; color: #c9d3ff; }
    input, select, textarea { width: 100%; box-sizing: border-box; padding: 8px; border-radius: 6px; border: 1px solid #2a355f; background: #0d1330; color: #e6e6e6; }
    textarea { min-height: 120px; resize: vertical; }
    button { padding: 8px 12px; border-radius: 6px; border: 1px solid #2a355f; background: #223068; color: #fff; cursor: pointer; }
    button:disabled { opacity: .6; cursor: default; }
    .row { display: flex; gap: 8px; align-items: center; }
    .row > * { flex: 1; }
    .muted { color: #a0a0aa; font-size: 12px; }
    .list { display: grid; gap: 8px; }
    .card { border: 1px solid #2a355f; padding: 8px; border-radius: 6px; background: #0d1330; display: grid; gap: 6px; }
    .mono { font-family: ui-monospace, SFMono-Regular, Menlo, Consolas, monospace; }
    .ok { color: #8df7b7; }
    .err { color: #ff8aa1; }
    .sep { height: 1px; background: #1f274a; margin: 8px 0; }

    /* Modal styles */
    .modal-backdrop { position: fixed; inset: 0; background: rgba(0,0,0,0.6); display: none; align-items: center; justify-content: center; z-index: 1000; }
    .modal-panel { width: min(640px, calc(100% - 32px)); background: #11162b; border: 1px solid #2a355f; border-radius: 10px; padding: 16px; box-shadow: 0 10px 30px rgba(0,0,0,0.4); display: grid; gap: 12px; }
    .modal-panel h3 { margin: 0; font-size: 16px; color: #9fb4ff; }
    .modal-actions { display: flex; gap: 8px; justify-content: flex-end; }
    .modal-panel .card { background: #0d1330; }
  </style>
</head>
<body>
  <header>
    <h1>fm-rss-reader-pb | 認証とAPIテスト</h1>
    <div>
      <a href="/rss.html" style="color:#9fb4ff; margin-right:12px; text-decoration:none;">RSS MCP テスター</a>
      <span id="authState" class="muted">未ログイン</span>
      <button id="logoutBtn" onclick="logout()" style="margin-left:8px; display:none;">ログアウト</button>
    </div>
  </header>

  <main>
    <section>
      <h2>1) ログイン (PocketBase auth)</h2>
      <div class="row">
        <div>
          <label for="identity">ユーザー (email or username)</label>
          <input id="identity" autocomplete="username" />
        </div>
        <div>
          <label for="password">パスワード</label>
          <input id="password" type="password" autocomplete="current-password" />
        </div>
      </div>
      <div class="row" style="margin-top:8px;">
        <button id="loginBtn" onclick="login()">ログイン</button>
        <button onclick="persistTokenToggle()">トークン保存: <span id="persistState">localStorage</span></button>
      </div>
      <div class="sep"></div>
      <div class="muted">成功時、以後のAPI呼び出しに Authorization: Bearer pbJWT を付与します。</div>
      <div id="loginMsg" class="mono"></div>
    </section>

    <section>
      <h2>1.5) JWT ツール (PB 認証トークン)</h2>
      <div class="row">
        <div>
          <div class="muted">現在の JWT (マスク表示)</div>
          <div id="jwtMasked" class="mono"></div>
        </div>
        <div style="flex:0 0 auto; display:grid; gap:8px;">
          <button onclick="copyJwtToClipboard()">JWT をコピー</button>
          <button onclick="sendJwtToRss()">RSS テスターへ転送</button>
        </div>
      </div>
      <div id="jwtMsg" class="mono"></div>
    </section>

    <section>
      <h2>2) MCP Tokens 管理 (一覧 / 取得 / 削除)</h2>
      <div class="row">
        <button onclick="loadTokens()">一覧取得</button>
        <button onclick="createToken()">新規発行</button>
      </div>
      <div class="sep"></div>
      <div id="tokensList" class="list"></div>
      <div id="tokensMsg" class="mono"></div>
    </section>

    <section>
      <h2>3) LLM API テスト (/api/llm/query, /api/llm/stream)</h2>
      <div class="row">
        <div>
          <label for="llmType">タイプ</label>
          <select id="llmType">
            <option value="summarize">summarize</option>
            <option value="translate">translate</option>
            <option value="ask">ask</option>
          </select>
        </div>
        <div>
          <label for="llmModel">モデル名 (任意)</label>
          <input id="llmModel" placeholder="openrouter/auto" />
        </div>
      </div>
      <label for="llmText">本文 / 質問</label>
      <textarea id="llmText" placeholder="テキストまたは質問を入力"></textarea>
      <label for="llmTarget">targetLang (translate時のみ)</label>
      <input id="llmTarget" placeholder="ja / en など" />
      <div style="margin-top:8px;" class="row">
        <button onclick="callLLM()">問い合わせ (query)</button>
        <button id="llmStreamBtn" onclick="callLLMStream()" disabled title="未対応">ストリーム (stream)</button>
        <button id="llmStreamAbortBtn" onclick="abortLLMStream()" style="display:none;">中断</button>
      </div>
      <div class="sep"></div>
      <div id="llmResult" class="card">
        <div class="muted">結果 (query)</div>
        <div id="llmResultText" class="mono"></div>
        <div id="llmMeta" class="muted mono"></div>
      </div>
      <div id="llmStreamResult" class="card" style="display:none;">
        <div class="muted">ストリーム結果 (stream)</div>
        <div id="llmStreamResultText" class="mono" style="white-space: pre-wrap; min-height: 100px;"></div>
        <div id="llmStreamMeta" class="muted mono"></div>
      </div>
      <div id="llmMsg" class="mono"></div>

      <div class="sep"></div>
      <div class="row">
        <button onclick="loadLLMModels()">モデル一覧取得</button>
        <span class="muted">OpenRouter 上の利用可能モデル</span>
      </div>
      <div id="llmModelsMsg" class="mono"></div>
      <div id="llmModelsList" class="list"></div>
    </section>
  </main>

  <!-- Token once modal -->
  <div id="tokenModal" class="modal-backdrop" role="dialog" aria-modal="true" aria-labelledby="tokenModalTitle" style="display:none;">
    <div class="modal-panel">
      <h3 id="tokenModalTitle">新しい MCP トークン</h3>
      <div class="muted">このトークンは一度しか表示されません。安全な場所に保存してください。</div>
      <div id="tokenModalValue" class="card mono" style="word-break: break-all;"></div>
      <div class="modal-actions">
        <button onclick="copyTokenToClipboard()">コピー</button>
        <button onclick="closeTokenModal()">閉じる</button>
      </div>
      <div id="tokenModalMsg" class="mono"></div>
    </div>
  </div>

  <script>
  const state = {
    token: null, // pbJWT
    persistLocal: true,
    // For aborting the stream request
    abortController: null,
    // One-time token shown in modal
    oneTimeToken: null,
  };

  function storage() {
    return state.persistLocal ? window.localStorage : window.sessionStorage;
  }

  function persistTokenToggle() {
    state.persistLocal = !state.persistLocal;
    document.getElementById('persistState').textContent = state.persistLocal ? 'localStorage' : 'sessionStorage';
    if (state.token) {
      storage().setItem('pb_jwt', state.token);
    }
  }

  function readSavedToken() {
    const t = (localStorage.getItem('pb_jwt') || sessionStorage.getItem('pb_jwt'));
    if (t) {
      state.token = t;
      document.getElementById('authState').textContent = 'ログイン済み';
      document.getElementById('logoutBtn').style.display = '';
    } else {
      document.getElementById('authState').textContent = '未ログイン';
      document.getElementById('logoutBtn').style.display = 'none';
    }
    updateJwtUi();
  }

  function setMsg(id, text, isErr=false) {
    const el = document.getElementById(id);
    el.textContent = text;
    el.className = 'mono ' + (isErr ? 'err' : 'ok');
  }

  async function login() {
    setMsg('loginMsg', 'ログイン中...');
    try {
      const identity = document.getElementById('identity').value.trim();
      const password = document.getElementById('password').value;
      const res = await fetch('/api/collections/users/auth-with-password', {
        method: 'POST',
        headers: { 'Content-Type': 'application/json' },
        body: JSON.stringify({ identity, password })
      });
      if (!res.ok) {
        const err = await safeJson(res);
        throw new Error(JSON.stringify(err));
      }
      const data = await res.json();
      // PocketBase returns { token, record }
      state.token = data?.token || null;
      if (!state.token) throw new Error('pbJWTが取得できませんでした');
      storage().setItem('pb_jwt', state.token);
      document.getElementById('authState').textContent = 'ログイン済み';
      document.getElementById('logoutBtn').style.display = '';
      setMsg('loginMsg', 'ログイン成功');
    } catch (e) {
      setMsg('loginMsg', String(e), true);
    }
  }

  function logout() {
    storage().removeItem('pb_jwt');
    localStorage.removeItem('pb_jwt');
    sessionStorage.removeItem('pb_jwt');
    state.token = null;
    document.getElementById('authState').textContent = '未ログイン';
    document.getElementById('logoutBtn').style.display = 'none';
    setMsg('loginMsg', 'ログアウトしました');
    updateJwtUi();
  }

  function authHeaders() {
    const h = { 'Content-Type': 'application/json' };
    if (state.token) h['Authorization'] = 'Bearer ' + state.token;
    return h;
  }

  // ========== MCP Tokens ==========
  async function loadTokens() {
    setMsg('tokensMsg', '取得中...');
    // NOTE: Do not hide the one-time token box here.
    // Users may still be copying the just-created token.
    try {
      const res = await fetch('/api/mcp/tokens', { headers: authHeaders() });
      if (!res.ok) throw await res.text();
      const data = await res.json();
      renderTokens(data?.items || []);
      setMsg('tokensMsg', 'OK');
    } catch (e) {
      setMsg('tokensMsg', 'エラー: ' + String(e), true);
    }
  }

  function renderTokens(items) {
    const list = document.getElementById('tokensList');
    list.innerHTML = '';
    if (!items.length) {
      const d = document.createElement('div');
      d.className = 'muted';
      d.textContent = 'トークンはありません';
      list.appendChild(d);
      return;
    }
    for (const it of items) {
      const card = document.createElement('div');
      card.className = 'card';
      card.innerHTML = `
        <div class="mono">id: ${esc(it.id)}${it.name ? ` | name: ${esc(it.name)}` : ''}</div>
        <div class="mono muted">scopes: ${esc(JSON.stringify(it.scopes || []))}</div>
        <div class="mono muted">expiresAt: ${esc(it.expiresAt || '')}</div>
        <div class="mono muted">lastUsedAt: ${esc(it.lastUsedAt || '')}</div>
        <div class="row">
          <span></span>
          <button onclick="deleteToken('${it.id}')">削除</button>
        </div>
      `;
      list.appendChild(card);
    }
  }

  async function createToken() {
    setMsg('tokensMsg', '発行中...');
    try {
      const name = prompt('任意の表示名 (空でも可)') || undefined;
      const res = await fetch('/api/mcp/tokens', {
        method: 'POST',
        headers: authHeaders(),
        body: JSON.stringify({ name })
      });
      if (!res.ok) throw await res.text();
      const data = await res.json();
      // 一度だけモーダルで表示
      openTokenModal(data.token);
      setMsg('tokensMsg', '発行しました。');
      // リスト更新
      await loadTokens();
    } catch (e) {
      setMsg('tokensMsg', 'エラー: ' + String(e), true);
    }
  }

  async function deleteToken(id) {
    if (!confirm('トークンを削除しますか？')) return;
    setMsg('tokensMsg', `削除中...`);
    try {
      const res = await fetch('/api/mcp/tokens/' + encodeURIComponent(id), {
        method: 'DELETE',
        headers: authHeaders()
      });
      if (!res.ok) throw await res.text();
      setMsg('tokensMsg', '削除しました');
      await loadTokens();
    } catch (e) {
      setMsg('tokensMsg', 'エラー: ' + String(e), true);
    }
  }

  // ======== Token modal ========
  function openTokenModal(token) {
    state.oneTimeToken = token || '';
    const modal = document.getElementById('tokenModal');
    const val = document.getElementById('tokenModalValue');
    const msg = document.getElementById('tokenModalMsg');
    val.textContent = state.oneTimeToken || '(取得できませんでした)';
    msg.textContent = '';
    msg.className = 'mono';
    modal.style.display = 'flex';
  }

  function closeTokenModal() {
    const modal = document.getElementById('tokenModal');
    const val = document.getElementById('tokenModalValue');
    modal.style.display = 'none';
    val.textContent = '';
    // 念のためトークン文字列をメモリからも消去
    state.oneTimeToken = null;
  }

  async function copyTokenToClipboard() {
    const token = state.oneTimeToken || '';
    const msg = document.getElementById('tokenModalMsg');
    try {
      if (navigator.clipboard && window.isSecureContext) {
        await navigator.clipboard.writeText(token);
      } else {
        // Fallback: create a temporary textarea
        const ta = document.createElement('textarea');
        ta.value = token;
        ta.style.position = 'fixed';
        ta.style.left = '-1000px';
        document.body.appendChild(ta);
        ta.focus();
        ta.select();
        document.execCommand('copy');
        document.body.removeChild(ta);
      }
      msg.textContent = 'コピーしました';
      msg.className = 'mono ok';
    } catch (err) {
      msg.textContent = 'コピーに失敗しました: ' + String(err);
      msg.className = 'mono err';
    }
  }


  function jwtMaskedText() {
    const t = state.token || localStorage.getItem('pb_jwt') || sessionStorage.getItem('pb_jwt') || '';
    if (!t) return '(なし)';
    if (t.length <= 12) return t;
    return t.slice(0, 6) + '...' + t.slice(-6);
  }
  function updateJwtUi() {
    const el = document.getElementById('jwtMasked');
    if (el) el.textContent = jwtMaskedText();
  }
  async function copyJwtToClipboard() {
    const token = state.token || localStorage.getItem('pb_jwt') || sessionStorage.getItem('pb_jwt') || '';
    const msgEl = document.getElementById('jwtMsg');
    try {
      if (!token) throw new Error('JWT がありません');
      if (navigator.clipboard && window.isSecureContext) {
        await navigator.clipboard.writeText(token);
      } else {
        const ta = document.createElement('textarea');
        ta.value = token; ta.style.position='fixed'; ta.style.left='-1000px';
        document.body.appendChild(ta); ta.focus(); ta.select(); document.execCommand('copy'); document.body.removeChild(ta);
      }
      msgEl.textContent = 'JWT をクリップボードにコピーしました';
      msgEl.className = 'mono ok';
    } catch (err) {
      msgEl.textContent = 'コピーに失敗: ' + String(err);
      msgEl.className = 'mono err';
    }
  }
  function sendJwtToRss() {
    const token = state.token || localStorage.getItem('pb_jwt') || sessionStorage.getItem('pb_jwt') || '';
    const msgEl = document.getElementById('jwtMsg');
    if (!token) {
      msgEl.textContent = 'JWT がありません';
      msgEl.className = 'mono err';
      return;
    }
    localStorage.setItem('pb_jwt_alt', token);
    msgEl.textContent = 'RSS テスターへ転送しました (pb_jwt_alt に保存)';
    msgEl.className = 'mono ok';
    // ナビゲーション
    window.location.href = '/rss.html';
  }

  // ========== LLM ==========
  async function loadLLMModels() {
    setMsg('llmModelsMsg', 'モデル取得中...');
    try {
      const res = await fetch('/api/llm/models', { headers: authHeaders() });
      const j = await safeJson(res);
      if (!res.ok) throw new Error(JSON.stringify(j));
      renderLLMModels(j.models || []);
      setMsg('llmModelsMsg', 'OK');
    } catch (e) {
      setMsg('llmModelsMsg', 'エラー: ' + String(e), true);
    }
  }

  function renderLLMModels(items) {
    const list = document.getElementById('llmModelsList');
    list.innerHTML = '';
    if (!items || !items.length) {
      const d = document.createElement('div');
      d.className = 'muted';
      d.textContent = 'モデルはありません';
      list.appendChild(d);
      return;
    }
    for (const m of items) {
      const card = document.createElement('div');
      card.className = 'card';
      card.innerHTML = `
        <div class="mono">id: ${esc(m.id)}</div>
        <div class="mono muted">name: ${esc(m.name || '')}</div>
        ${m.description ? `<div class="mono muted">desc: ${esc(m.description)}</div>` : ''}
        <div class="row">
          <span></span>
          <button onclick="document.getElementById('llmModel').value='${esc(m.id)}'">このモデルを設定</button>
        </div>
      `;
      list.appendChild(card);
    }
  }

  async function callLLM() {
    setMsg('llmMsg', '問い合わせ中...');
    try {
      const type = document.getElementById('llmType').value;
      const model = document.getElementById('llmModel').value.trim();
      const text = document.getElementById('llmText').value.trim();
      const targetLang = document.getElementById('llmTarget').value.trim();

      // Simple client-side validation
      if ((type === 'ask' || type === 'summarize' || type === 'translate') && !text) {
        setMsg('llmMsg', '本文/質問を入力してください', true);
        return;
      }

      const payload = {};
      if (type === 'summarize') {
        payload.text = text;
      } else if (type === 'translate') {
        payload.text = text; payload.targetLang = targetLang || 'ja';
      } else if (type === 'ask') {
        payload.question = text; // server also accepts payload.text fallback
      }

      const body = { type, payload };
      if (model) body.model = model;

      const res = await fetch('/api/llm/query', {
        method: 'POST',
        headers: authHeaders(),
        body: JSON.stringify(body)
      });
      const j = await safeJson(res);
      if (!res.ok) throw new Error(JSON.stringify(j));

      if (typeof j.result === 'string') {
        document.getElementById('llmResultText').textContent = j.result ?? '';
      } else if (j.error) {
        document.getElementById('llmResultText').textContent = JSON.stringify(j.error);
      } else {
        document.getElementById('llmResultText').textContent = JSON.stringify(j, null, 2);
      }
      document.getElementById('llmMeta').textContent = JSON.stringify({ model: j.model, usage: j.usage }, null, 2);
      setMsg('llmMsg', 'OK');
    } catch (e) {
      setMsg('llmMsg', 'エラー: ' + String(e), true);
    }
  }

  // ========== LLM Stream ==========
  // Call the streaming LLM API endpoint
  async function callLLMStream() {
    // SSE は PocketBase JSVM の制約により未対応とします。
    setMsg('llmMsg', 'ストリームは現在未対応です', true);
    document.getElementById('llmStreamResult').style.display = 'none';
    return;
  }

  // Abort the ongoing LLM stream request
  function abortLLMStream() {
    if (state.abortController) {
      state.abortController.abort();
      state.abortController = null;
    }
  }

  // ========== Utils ==========
  function esc(s) { return String(s).replace(/[&<>"']/g, c => ({'&':'&amp;','<':'&lt;','>':'&gt;','"':'&quot;','\'':'&#39;'}[c])); }
  async function safeJson(res) {
    const text = await res.text();
    try { return JSON.parse(text); } catch { return { raw: text }; }
  }

  // boot
  readSavedToken();
  </script>
</body>
</html>

